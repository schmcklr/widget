{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst commons_js_1 = require(\"./commons.js\");\n\nconst base64_arraybuffer_1 = require(\"@socket.io/base64-arraybuffer\");\n\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n\nconst decodePacket = (encodedPacket, binaryType) => {\n  if (typeof encodedPacket !== \"string\") {\n    return {\n      type: \"message\",\n      data: mapBinary(encodedPacket, binaryType)\n    };\n  }\n\n  const type = encodedPacket.charAt(0);\n\n  if (type === \"b\") {\n    return {\n      type: \"message\",\n      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\n    };\n  }\n\n  const packetType = commons_js_1.PACKET_TYPES_REVERSE[type];\n\n  if (!packetType) {\n    return commons_js_1.ERROR_PACKET;\n  }\n\n  return encodedPacket.length > 1 ? {\n    type: commons_js_1.PACKET_TYPES_REVERSE[type],\n    data: encodedPacket.substring(1)\n  } : {\n    type: commons_js_1.PACKET_TYPES_REVERSE[type]\n  };\n};\n\nconst decodeBase64Packet = (data, binaryType) => {\n  if (withNativeArrayBuffer) {\n    const decoded = (0, base64_arraybuffer_1.decode)(data);\n    return mapBinary(decoded, binaryType);\n  } else {\n    return {\n      base64: true,\n      data\n    }; // fallback for old browsers\n  }\n};\n\nconst mapBinary = (data, binaryType) => {\n  switch (binaryType) {\n    case \"blob\":\n      return data instanceof ArrayBuffer ? new Blob([data]) : data;\n\n    case \"arraybuffer\":\n    default:\n      return data;\n    // assuming the data is already an ArrayBuffer\n  }\n};\n\nexports.default = decodePacket;","map":{"version":3,"sources":["C:/Users/Kevin/Documents/Chat_Bot/widget/node_modules/engine.io-parser/build/cjs/decodePacket.browser.js"],"names":["Object","defineProperty","exports","value","commons_js_1","require","base64_arraybuffer_1","withNativeArrayBuffer","ArrayBuffer","decodePacket","encodedPacket","binaryType","type","data","mapBinary","charAt","decodeBase64Packet","substring","packetType","PACKET_TYPES_REVERSE","ERROR_PACKET","length","decoded","decode","base64","Blob","default"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,MAAMC,YAAY,GAAGC,OAAO,CAAC,cAAD,CAA5B;;AACA,MAAMC,oBAAoB,GAAGD,OAAO,CAAC,+BAAD,CAApC;;AACA,MAAME,qBAAqB,GAAG,OAAOC,WAAP,KAAuB,UAArD;;AACA,MAAMC,YAAY,GAAG,CAACC,aAAD,EAAgBC,UAAhB,KAA+B;AAChD,MAAI,OAAOD,aAAP,KAAyB,QAA7B,EAAuC;AACnC,WAAO;AACHE,MAAAA,IAAI,EAAE,SADH;AAEHC,MAAAA,IAAI,EAAEC,SAAS,CAACJ,aAAD,EAAgBC,UAAhB;AAFZ,KAAP;AAIH;;AACD,QAAMC,IAAI,GAAGF,aAAa,CAACK,MAAd,CAAqB,CAArB,CAAb;;AACA,MAAIH,IAAI,KAAK,GAAb,EAAkB;AACd,WAAO;AACHA,MAAAA,IAAI,EAAE,SADH;AAEHC,MAAAA,IAAI,EAAEG,kBAAkB,CAACN,aAAa,CAACO,SAAd,CAAwB,CAAxB,CAAD,EAA6BN,UAA7B;AAFrB,KAAP;AAIH;;AACD,QAAMO,UAAU,GAAGd,YAAY,CAACe,oBAAb,CAAkCP,IAAlC,CAAnB;;AACA,MAAI,CAACM,UAAL,EAAiB;AACb,WAAOd,YAAY,CAACgB,YAApB;AACH;;AACD,SAAOV,aAAa,CAACW,MAAd,GAAuB,CAAvB,GACD;AACET,IAAAA,IAAI,EAAER,YAAY,CAACe,oBAAb,CAAkCP,IAAlC,CADR;AAEEC,IAAAA,IAAI,EAAEH,aAAa,CAACO,SAAd,CAAwB,CAAxB;AAFR,GADC,GAKD;AACEL,IAAAA,IAAI,EAAER,YAAY,CAACe,oBAAb,CAAkCP,IAAlC;AADR,GALN;AAQH,CA1BD;;AA2BA,MAAMI,kBAAkB,GAAG,CAACH,IAAD,EAAOF,UAAP,KAAsB;AAC7C,MAAIJ,qBAAJ,EAA2B;AACvB,UAAMe,OAAO,GAAG,CAAC,GAAGhB,oBAAoB,CAACiB,MAAzB,EAAiCV,IAAjC,CAAhB;AACA,WAAOC,SAAS,CAACQ,OAAD,EAAUX,UAAV,CAAhB;AACH,GAHD,MAIK;AACD,WAAO;AAAEa,MAAAA,MAAM,EAAE,IAAV;AAAgBX,MAAAA;AAAhB,KAAP,CADC,CAC8B;AAClC;AACJ,CARD;;AASA,MAAMC,SAAS,GAAG,CAACD,IAAD,EAAOF,UAAP,KAAsB;AACpC,UAAQA,UAAR;AACI,SAAK,MAAL;AACI,aAAOE,IAAI,YAAYL,WAAhB,GAA8B,IAAIiB,IAAJ,CAAS,CAACZ,IAAD,CAAT,CAA9B,GAAiDA,IAAxD;;AACJ,SAAK,aAAL;AACA;AACI,aAAOA,IAAP;AAAa;AALrB;AAOH,CARD;;AASAX,OAAO,CAACwB,OAAR,GAAkBjB,YAAlB","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst commons_js_1 = require(\"./commons.js\");\nconst base64_arraybuffer_1 = require(\"@socket.io/base64-arraybuffer\");\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nconst decodePacket = (encodedPacket, binaryType) => {\n    if (typeof encodedPacket !== \"string\") {\n        return {\n            type: \"message\",\n            data: mapBinary(encodedPacket, binaryType)\n        };\n    }\n    const type = encodedPacket.charAt(0);\n    if (type === \"b\") {\n        return {\n            type: \"message\",\n            data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\n        };\n    }\n    const packetType = commons_js_1.PACKET_TYPES_REVERSE[type];\n    if (!packetType) {\n        return commons_js_1.ERROR_PACKET;\n    }\n    return encodedPacket.length > 1\n        ? {\n            type: commons_js_1.PACKET_TYPES_REVERSE[type],\n            data: encodedPacket.substring(1)\n        }\n        : {\n            type: commons_js_1.PACKET_TYPES_REVERSE[type]\n        };\n};\nconst decodeBase64Packet = (data, binaryType) => {\n    if (withNativeArrayBuffer) {\n        const decoded = (0, base64_arraybuffer_1.decode)(data);\n        return mapBinary(decoded, binaryType);\n    }\n    else {\n        return { base64: true, data }; // fallback for old browsers\n    }\n};\nconst mapBinary = (data, binaryType) => {\n    switch (binaryType) {\n        case \"blob\":\n            return data instanceof ArrayBuffer ? new Blob([data]) : data;\n        case \"arraybuffer\":\n        default:\n            return data; // assuming the data is already an ArrayBuffer\n    }\n};\nexports.default = decodePacket;\n"]},"metadata":{},"sourceType":"script"}